# Протокольно-Ориентированное Программирование
Разберёмся в таких темах, как Протокольные Типы и Обобщенный (Generic) код. 

## Протокольные Типы
По ходу, будут рассмотренны следующие вопросы:
+ как объекты протокольных типов хранятся и копируются
+ как с ними работает Method Dispatch
	
#### Реализация полиморфизма без наследования и ссылочных типов:
```swift
protocol Drawable { func draw() {} }

struct Point: Drawable {
    var x, y: Int
    func draw() {
        ...
    }
}

struct Line: Drawable {
    var x1, x2, y1, y2: Int
    func draw() {
        ...
    }
}

var drawbles = [Drawable]()

for d in drawbles {
    d.draw()
}
```
Полиморфизм по прежнему работает. Элемент `d` массива `drawables` имеет один интерфейс, который обозначен в протоколе `Drawable`, но имеет разные реализации своих методов, которые обозначены в `Line` и `Point`.

> Главный принцип (ad-hoc) полиморфизма: "Общий интерфейс - много реализаций"

#### Dynamic dispatch без virtual-table
Напомним, что определение корректной реализации метода при работе с классами (ссылочными типами) достигается через Dynamic dispatch и виртуальную таблицу. Виртуальная таблица есть у каждого классового типа, хранит в себе реализации методов для этого типа. Dynamic dispatch определяет реализацию метода для типа, заглядывая в его виртуальную таблицу. Все это необходимо из-за возможности наследования и переопределения методов.

В случае структур наследование, также как и переопределение, невозможно. Тогда, на первый взгляд, в virtual-table нет надобности, но как тогда будет работать Dynamic dispatch? Как программе понять, какой метод будет вызван на `d.draw()`? Метод `Line`, `Point` или любого другого типа, который соотвествует протоколу `Drawable`?

## Protocol Witness Table 
- является ответом на этот вопрос
Каждый тип, который реализовал какой-либо протокол, имеет эту таблицу. Как и виртуальная таблица для классов, хранит в себе реализцаии методов, которые требует протокол (TODO: требует?).

> в дальнейшем Protocol Witness Table будет называтьсь "протокольной таблицу"

Отлично, теперь мы знаем где искать реализации методов. Остается лишь **два вопроса**:
1. Как найти соответствующую протокольную таблицу для того или иного объекта, который реализовал этот протокол? Как, в нашем случае, найти протокольную таблицу для элемента `d` массива `drawables`?
2. Элементы массива должны быть одного размера (в этом и есть суть массива). Тогда как массив `drawable` может соответствовать этому требованию, если он может хранить в себе и `Line` и `Point`, а они имеют разные размеры?

```swift
MemoryLayout.size(ofValue: Line(...))  // 32 bits
MemoryLayout.size(ofValue: Point(...)) // 16 bits
```

## Existential Container
Для решения этих двух вопросов, в Swift используется специальная схема хранения, которая называется **Existential Container**. Выглядит она вот так:
|              |
|--------------|
| value buffer |
|              |
| vwt          |
| pwt          |

Занимает 5 машинных слов (в x64 битной системе 5 * 8 = 40 бит). Разделен на три части:
1. value buffer - пространство для самого инстанса
2. vwt - указатель на Value Witness Table
3. pwt - указатель на Protocol Witness Table

Рассмотрим все три части подробнее:
##### Value Buffer
Просто три машинных слова для хранения инстанса. Если инстанс может уместиться в value buffer, то он в нем и хранится. Если инстанс больше 3 машинных слов, то он не может уместиться в нем и программа вынуждена выделить память на хипе, сложить туда инстанс, а в value buffer положить указатель к этой памяти. Рассмотрим на примере:
```swift
let point: Drawable = Point(...)
```
`Point()` занимает 2 машинных слова и прекрасно может поместиться в value buffer - программа сложит его туда: 
| x: Int       |
| y: Int       |
| -            |
| vwt          |
| pwt          |

```swift
let line: Drawable = Line(...)
```
`Line()` занимает 4 машинных слова и не может поместиться в value buffer - программа выделит для нее память на хипе, а в value buffer сложит поинтер на эту память:
| ptr: Pointer | -> |         |
| -            |    |         |
| -            |    | x1: Int |
| vwt          |    | y1: Int |
| pwt          |    | x2: Int |
                    | y2: Int |

##### Value Witness Table
Также как и протокольная таблица, эта таблица есть у каждого типа, который соответствует протоколу. Содержит в себе реализцию четырех методов: allocate, copy, destruct, deallocate. Этими методами управляется весь жизненный цикл объекта. Рассмотрим на примере:
1. При создании объекта (`Point(...) as Drawable`) вызывается метод `allocate` из VWT этого объекта. Метод allocate решит где должно быть размещенно содержимое объекта (в value buffer или на хипе) и если он должен быть размещен на хипе, то выделит необходимое количество памяти
2. Метод `copy` поместит содержимое объекта в соответствующее месте
3. После окончания работы с объектом вызовется метод `destruct`, который убавит (TODO: убавит?) все счетчики ссылок, если содержимое хранится на хипе
4. После `destruct` будет вызван метод `deallocate`, который освободит выделенную на хипе память, если таковая имеется

##### Protocol Witness Table
Как было описанно выше, содержит в себе реализации требуемых протоколом методов для типа, к которому эта таблица привязана.

##### Existential Container - Ответы
Таким образом мы ответили на эти два вопроса:
1. Protocol Witness Table хранится Existential Container-е этого объекта и может быть без труда получена
2. Если тип элемента массива является протоколом, то любой элемент этого массива занимает фиксирвоанное значение в 5 машинных слов - именно столько необходимо для Existential Container. Если содержимое элемента не может быть помещено в value buffer, то он будет размещен на хипе. Если может, то все содержимое будет размещенно в value buffer.
```swift
let line: Drawable = Line(...)
MemoryLayout.size(ofValue: line) // 40 бит

let drawables: [Drawable] = [Line(...), Point(...), Line(...)]
MemoryLayout.size(ofValue: drawables._content) // 120 бит
```


##### Existential Container - Пример
Рассмсотрим поведение existential container-а в этом коде:
```swift
func drawACopy(local: Drawable) {
	local.draw()
}
let val: Drawable = Line(...)
drawACopy(val)
```

> В качестве иллюстрации мы будем использовать Swift-Pseudo Code

```swift
struct ExistContDrawable {
	var valueBuffer: (Int, Int, Int)
	var vwt: ValueWitnessTable
	var pwt: ProtocolWitnessTable
}
```

***Псевдо код***
```swift
func drawACopy(val: ExistContDrawable) {
	...
}
```
За кулисами функция `drawACopy` принимает в себя `ExistContDrawable`

```swift
func drawACopy(val: ExistContDrawable) {
	var local = ExistContDrawable()
	let vwt = val.vwt
	let pwt = val.pwt
	local.type = type
	local.pwt = pwt
	...
}
```
Параметр функции создается вручную: создаем контейнер, заполняем его поля из полученного аргумента

```swift
func drawACopy(val: ExistContDrawable) {
	...
	vwt.allocateBufferAndCopy(&local, val)
}
```
Решаем где будет хранится содержимое (в буффере или хипе). Вызываем vwt.allocate и vwt.copy чтобы заполнить local содержимым val

```swift
func drawACopy(val: ExistContDrawable) {
	...
	pwt.draw(vwt.projectBuffer(&local))
}
```
Вызываем метод `draw` и передаем ему указатель на `self` (метод, потому, что надо решить на что указатель - на начало буффера или на хип)

```swift
func drawACopy(val: ExistContDrawable) {
	...
	vwt.destructAndDeallocateBuffer(&local)
}
```
Завершаем работу с `local`. Чистим все ссылки на хип от `local`. Функция возвращает значение - pop stack frame of `drawACopy`
